name: Setup Org
on:
  workflow_dispatch:
  
description: >-
  Populate a given Org with OneTemplate configuration.
inputs:
  target-org:
    description: >-
      Username of alias of an already existent Org to configure. If not given,
      default Org will be used.
  user-emails:
    description: >-
      Optional whitespace-separated list of e-mail addresses, for which separate
      extra users will be created on the Org. NOTE: Only applies to dev Orgs
      because that's the only Org type where users can be created
      programmatically using SF CLI.
  extra-users-profile-name:
    default: System Administrator
    description: >-
      API name of a Profile to which the extra users shall be assigned.
  set-up-dependencies:
    default: 'true'
    description: >-
      Whether to set up project dependencies on the Org, for instance to install
      dependency packages like Apex Trigger Actions Framework and Field Service.
  deploy-codebase:
    default: 'true'
    description: >-
      Whether to deploy metadata of the project (located in source directories)
      onto the Org.
  as-packages:
    default: 'false'
    description: >-
      Whether to deliver project functionality by INSTALLING project PACKAGES.
      Otherwise, metadata components shall be deployed UNPACKAGED through
      Metadata API.
      NOTE: This does NOT have effect if deploy-codebase isn't set to `true`.
  insert-sample-data:
    default: 'true'
    description: >-
      Whether to insert sample data records onto the Org.
  dev-org-exclusive:
    # The default is `false` because this flag strives further away from
    # production-like setup and towards a development environment setup.
    #
    # We should favor production-like setups because then this action's
    # invocation is the simplest and introduces the least risk of
    # misconfiguring.
    #
    # On the other hand, less production-like setups (e.g. development
    # environments, dev Orgs) should require more elaborate invocation.
    default: 'false'
    description: >-
      Whether to perform additional setup steps exclusive to dev Orgs.
runs:
  using: composite
  steps:
    - name: Set up Helper Functions
      shell: sh
      env:
        SF_ORG_ASSIGN_PERMSET_UPSERT_SH: |
          # Assign permissionsets, but ignore (and dont fail due to) already
          # existing assignments (duplicates).
          sf_org_assign_permset_upsert()
          (
            report="$(sf org assign permset "$@" --json)" &&:
            status=$?
            #
            echo ::group::Permission Set Assignment
            printf %s\\n "$report"
            echo ::endgroup::
            #
            # Status == `0` means full success.
            [ $((status)) -eq 0 ] && return 0
            #
            # Status == '68' means partial success. NOTE that successful PermSet
            # assignments still get committed. Therefore, treat it as a success
            # ONLY IF there were no errors OTHER THAN duplicate assignments.
            #
            # Status == '1' means failure. Therefore, treat it as a success
            # ONLY IF there were no errors OTHER THAN duplicate assignments.
            if [ $((status)) -eq 68 ] || [ $((status)) -eq 1 ]; then
              errors_except_dupl_assignment="$(
                printf %s "$report" \
                | jq -r '
                  .result.failures[]
                  | select(
                    .message | test("Duplicate PermissionSetAssignment") | not)'
              )"
              if [ -z "$errors_except_dupl_assignment" ]; then
                return 0
              fi
            fi
            #
            return $((status))
          )
      run: |
        printf %s\\n \
          'SF_ORG_ASSIGN_PERMSET_UPSERT_SH<<EOV' \
          "$SF_ORG_ASSIGN_PERMSET_UPSERT_SH" \
          EOV \
        >> "$GITHUB_ENV"
    - name: Set Up Repeating Parameters
      shell: sh
      env:
        TARGET_ORG: ${{ inputs.target-org }}
      run: |
        printf %s\\n "TARGET_ORG=$TARGET_ORG" >> "$GITHUB_ENV"
    - name: Create Extra Users
      if: ${{ inputs.user-emails }}
      env:
        USER_EMAILS: ${{ inputs.user-emails }}
        EXTRA_USERS_PROFILE_NAME: >-
          ${{ inputs.extra-users-profile-name || 'System Administrator' }}
      shell: bash
      run: |
        instance_url="$(
          sf org display --json ${TARGET_ORG:+"--target-org=$TARGET_ORG"} \
          | jq -r .result.instanceUrl
        )"
        domain_name="${instance_url#*://}"

        declare -a usernames=()

        for email in ${USER_EMAILS-}; do
          user="${email%%@*}"
          username="${user}@${domain_name}"
          usernames+=("$username")
          authfile="dev-org-authfile-${user//./-}.json"
          userfile="dev-org-userfile-${user//./-}.json"
          sf org create user \
            ${TARGET_ORG:+"--target-org=$TARGET_ORG"} \
            generatePassword=true \
            profileName="${EXTRA_USERS_PROFILE_NAME:?}" \
            Username="$username" \
            Email="$email" \
          ;
          sf org display \
            --json \
            --verbose \
            --target-org="$username" \
            > "$authfile" \
          ;
          sf org display user \
            --json \
            --target-org="$username" \
            > "$userfile" \
          ;
        done
        printf %s\\n "USERNAMES=${usernames[*]}" >> "$GITHUB_ENV"
    # BEGIN Set Up Project Dependencies
    - name: Install the TriggerActionsFramework Dependency
      if: ${{ inputs.set-up-dependencies == 'true' }}
      uses: ./.github/actions/install-package-version
      with:
        target-org: ${{ inputs.target-org }}
        package-name: TriggerActionsFramework@0.2.1
        seek-installation-key: false
    # END Set Up Project Dependencies
    - name: Assign Mandatory Permission Sets
      shell: sh
      run: |
        # load action-wide helper function for assigning permsets:
        eval "$SF_ORG_ASSIGN_PERMSET_UPSERT_SH"

        # Those permission set are required to interact with AutoCloud features
        # and to deploy properly project metadata.
        echo INFO: Assigning mandatory PSs to the default user...
        sf_org_assign_permset_upsert \
          ${TARGET_ORG:+"--target-org=$TARGET_ORG"} \
          --name PS1 \
          --name PS2 \
          --name PS3 \
        ;

        # load $USERNAMES into $@ with '--on-behalf-of=' prefix each:
        set --
        for username in ${USERNAMES-}; do
          set -- "$@" --on-behalf-of="$username"
        done
        [ $# -eq 0 ] && exit 0

        echo INFO: Assigning mandatory PSs to the extra users...
        sf_org_assign_permset_upsert \
          ${TARGET_ORG:+"--target-org=$TARGET_ORG"} \
          --name PS1 \
          --name PS2 \
          --name PS3 \
          "$@" \
        ;
    - name: Disable All Custom Duplicate and Matching Rules on the Org
      # This is to ensure that if there are any such Rules in this deployment,
      # they won't collide with any activated Rules and cause an error.
      if: ${{ inputs.deploy-codebase == 'true' }}
      uses: ./.github/actions/toggle-org-rules
      with:
        target-org: ${{ inputs.target-org }}
        rules-source: org
        operation: disable
    - name: Deactivate All Duplicate and Matching Rules in the Repository
      # This is to ensure that all Rules during deployment will not change state,
      # from deactivated into activated. Salesforce is throwing an error during deployment,
      # if you are trying to activate AND update any of a Rule in one deployment action.
      if: ${{ inputs.deploy-codebase == 'true' }}
      shell: sh
      run: |
        echo ::group::Deactivate Matching and Duplicate Rules in our codebase
        find ./force-app*/main/default/matchingRules \
          -type f \
          -exec sed -i 's|<ruleStatus>Active</ruleStatus>|<ruleStatus>Inactive</ruleStatus>|g' {} +
        find ./force-app*/main/default/duplicateRules \
          -type f \
          -exec sed -i 's|<isActive>true</isActive>|<isActive>false</isActive>|g' {} +
        echo ::endgroup::
    - name: Pre-Deploy Some dev Org Adjustments
      # Some dev-Org-specific adjustments - namely Flexipages and
      # Layouts - need to be present on the Org early, because other
      # components, e.g. Applications and Profiles in Base, refer to them.
      # These deployed components are already present on Sandboxes, so they
      # don't need to be deployed in those cases, but they're lacking for
      # dev Orgs.
      if: >-
        inputs.deploy-codebase == 'true'
        && inputs.as-packages != 'true'
        && inputs.dev-org-exclusive == 'true'
      shell: sh
      env:
        TARGET_ORG: ${{ inputs.target-org }}
      run: |
        # Pre-Deploy Some dev Org Adjustments
        echo ::group::Pre-Deploy Some dev Org Adjustments
        trap 'echo ::endgroup::' EXIT
        sf project deploy start \
          --json \
          ${TARGET_ORG:+"--target-org=$TARGET_ORG"} \
          --source-dir=force-app-dev-org-adjustments/main/default/flexipages \
          --source-dir=force-app-dev-org-adjustments/main/default/layouts \
        ;
    - name: Deploy Pre Metadata
      # TODO: PoC if that step is necessary, considering it's used as seedMetadata.
      if: >-
        ${{ inputs.deploy-codebase == 'true' && inputs.as-packages == 'true' }}
      shell: sh
      run: |
        # Deploy Pre Metadata
        if [ -d force-app-pre ] && [ "$(find force-app-pre -type f)" ]; then
          (
            echo ::group::Deploy Pre Metadata
            trap 'echo ::endgroup::' EXIT
            sf project deploy start \
              --json \
              --wait 33 \
              --ignore-conflicts \
              ${TARGET_ORG:+"--target-org=$TARGET_ORG"} \
              --source-dir force-app-pre \
            ;
          )
        else
          echo '::notice file=force-app-pre/::Nothing to deploy.'
        fi
    - name: Deploy Project Metadata 
      if: >-
        ${{ inputs.deploy-codebase == 'true' && inputs.as-packages != 'true' }}
      shell: sh
      run: |
        # Deploy Project Metadata 
        # Addiotional deployment for Asset OWD is because without this change
        # sharing rule for Asset is failing to missing Asset OWD information
        (
          mv -v \
            force-app-data-model/main/default/objects/Order/fields \
            force-app-temp \
          ;
          echo INFO: Temporarily excluded Order fields from deployment.
          echo ::group::Deploy Order Object Customizations
          _cleanup()
          (
            echo ::endgroup::
            mv -v \
              force-app-temp \
              force-app-data-model/main/default/objects/Order/fields \
            ;
          )
          trap _cleanup EXIT
          sf project deploy start \
            --json \
            --ignore-conflicts \
            ${TARGET_ORG:+"--target-org=$TARGET_ORG"} \
            --source-dir ./force-app-data-model/main/default/objects/Order \
          ;
        )
        (
          mv -v \
            force-app-data-model/main/default/objects/Asset/fields \
            force-app-temp \
          ;
          echo INFO: Temporarily excluded Asset fields from deployment.
          echo ::group::Deploy Asset Object Customizations
          _cleanup()
          (
            echo ::endgroup::
            mv -v \
              force-app-temp \
              force-app-data-model/main/default/objects/Asset/fields \
            ;
          )
          trap _cleanup EXIT
          sf project deploy start \
            --json \
            --ignore-conflicts \
            ${TARGET_ORG:+"--target-org=$TARGET_ORG"} \
            --source-dir ./force-app-data-model/main/default/objects/Asset \
          ;
        )
        
    - name: Deploy dev Org Adjustments
      if: >-
        inputs.deploy-codebase == 'true'
        && inputs.dev-org-exclusive == 'true'
      shell: sh
      env:
        TARGET_ORG: ${{ inputs.target-org }}
      run: |
        # Deploy dev Org Adjustments
        echo ::group::Deploy dev Org Adjustments
        trap 'echo ::endgroup::' EXIT
        sf project deploy start \
          --json \
          --ignore-conflicts \
          ${TARGET_ORG:+"--target-org=$TARGET_ORG"} \
          --source-dir=force-app-dev-org-adjustments \
        ;
    - name: Deploy Post-Base Metadata
      if: >-
        ${{ inputs.deploy-codebase == 'true' && inputs.as-packages == 'true' }}
      shell: sh
      run: |
        # Deploy Post-Base Metadata
        echo ::group::Deploy Post-Base Metadata
        trap 'echo ::endgroup::' EXIT
        sf project deploy start \
          --json \
          --ignore-conflicts \
          ${TARGET_ORG:+"--target-org=$TARGET_ORG"} \
          --source-dir force-app-base-post \
          --source-dir force-app-base/main/default/applications \
          --source-dir force-app-base/main/default/profiles \
        ;
    - name: Deploy Permission Sets to Ensure Proper Update
      # Permissions Sets are not updated during package update on org,
      # new permissions added between versions are not exisitng after package update
      #
      # To solve this problem new step is added to use deployment metadata API
      # to deliver new changes for Permission Sets.
      if: >-
        ${{ inputs.deploy-codebase == 'true' && inputs.as-packages == 'true' && inputs.dev-org-exclusive == 'false' }}
      shell: sh
      run: |
        # Deploy Permission Sets to Ensure Proper Update
        echo ::group::Permission Set Deployment
          sf project deploy start \
            --json \
            --ignore-conflicts \
            ${TARGET_ORG:+"--target-org=$TARGET_ORG"} \
            --metadata 'permissionset:*' \
          ;
        echo ::endgroup::
    - name: Deploy Picklist Fields to Ensure Proper Update
      # Picklist Fields new values are not updated during package update on org,
      # new values added between versions are not exisitng after package update
      #
      # To solve this problem new step is added to use deployment metadata API
      # to deliver new changes for Picklists.
      if: >-
        ${{ inputs.deploy-codebase == 'true' && inputs.as-packages == 'true' && inputs.dev-org-exclusive == 'false'}}
      shell: bash
      run: |
        picklist_array=()
        while IFS= read -r -d '' file; do
          # Check if the file contains the <type>Picklist</type> tag
          if grep -q '<type>Picklist</type>' "$file"; then
            # Add the file path to the array
            picklist_array+=("$file")
          fi
        done < <(find force-app-*/main/default/objects/*/fields -type f -name '*.xml' -print0)
        if [[ -z "$picklist_array" ]]; then
            echo ::notice \
              title=Picklist Fields Deployment::No Picklist Fields to deploy.
            exit 0
        fi
        deploy_command="sf project deploy start --source-dir"
        for file in "${picklist_array[@]}"; do
            deploy_command="$deploy_command \"$file\""
        done
        echo ::group::Picklist Fields Deployment
        eval "$deploy_command"
        echo ::endgroup::
    - name: Deploy Record Types to Ensure Proper Picklist Value Assignment
      # Record Types are deployed here explicitly through Metadata API, even
      # though they are getting delivered in previous steps through unlocked
      # packages.
      #
      # This is because when they're delivered only through packages,
      # picklist values for specific picklists may not be set to what is
      # defined within the component. Instead, picklist values will be set to
      # an unexpected state; either all picklist values will be assigned, or
      # none - the exact outcome is not fully investigated.
      if: >-
        ${{ inputs.deploy-codebase == 'true' && inputs.as-packages == 'true' && inputs.dev-org-exclusive == 'false' }}
      shell: sh
      run: |
        # Deploy Record Types to Ensure Proper Picklist Value Assignment
        find \
          force-app-base/main/default/objects \
          -type f \
          -name '*.recordType-meta.xml' \
        | (
          # Wipe the 'positional parameters' array and load to it all found
          # record type file paths, each prefixed with '--source-dir=', for
          # their later deployment.
          set --
          while read -r rtype_path; do
            set -- --source-dir="$rtype_path" "$@"
          done
          if [ $# -eq 0 ]; then
            echo ::notice \
              title=Record Type Deployment::No Record Types to deploy.
            exit 0
          fi
          echo ::group::Record Type Deployment
          sf project deploy start \
            --json \
            --ignore-conflicts \
            ${TARGET_ORG:+"--target-org=$TARGET_ORG"} \
            "$@" \
          ;
          echo ::endgroup::
        )
    - name: Enable All Project Matching- and Duplicate Rules
      # This is to automate a manual step of having to activate these rules
      # after deployment.
      if: ${{ inputs.deploy-codebase == 'true' }}
      uses: ./.github/actions/toggle-org-rules
      with:
        target-org: ${{ inputs.target-org }}
        rules-source: repo
        operation: enable
    - name: Assign Project Permission Set Groups
      if: ${{ inputs.deploy-codebase == 'true' }}
      shell: sh
      run: |
        # Assign Project Permission Set Groups

        # load action-wide helper function for assigning permsets:
        eval "$SF_ORG_ASSIGN_PERMSET_UPSERT_SH"
        # Those permission set groups are required to see
        # MB Autocloud app & MB Autocloud CCC app
        echo INFO: Assigning project PSGs to the default user...
        sf_org_assign_permset_upsert \
          ${TARGET_ORG:+"--target-org=$TARGET_ORG"} \
          --name OT_MOCSalesOperatorPC_PSG \
        ;

        # load $USERNAMES into $@ with '--on-behalf-of=' prefix each
        set --
        for username in ${USERNAMES-}; do
          set -- "$@" --on-behalf-of="$username"
        done
        [ $# -eq 0 ] && exit 0

        echo INFO: Assigning project PSGs to extra users...
        sf_org_assign_permset_upsert \
          ${TARGET_ORG:+"--target-org=$TARGET_ORG"} \
          --name OT_MOCSalesOperatorPC_PSG \
          "$@" \
        ;
    - name: Insert Sample Data
      if: ${{ inputs.insert-sample-data == 'true' }}
      shell: sh
      run: |
        # Insert Sample Data
        echo ::group::Insert Sample Data
        trap 'echo ::endgroup::' EXIT
        sf data import tree \
          ${TARGET_ORG:+"--target-org=$TARGET_ORG"} \
          --json \
          --plan sample-data/main-plan.json \
        ;
